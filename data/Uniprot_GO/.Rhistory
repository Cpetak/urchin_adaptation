#principal component analysis (PCA) can reveal some ‘structure’ in the genotypic data.
#We perfom PCA by using the prcomp function as follows.
pc <- prcomp(Y)
plot(pc$sdev[1:20]^2, xlab = 'PC', ylab = "Variance explained")
points(6,pc$sdev[6]^2, type = "h", lwd = 3, col = "blue")
#order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
freqs<- c(0.05026657,0.07188418,0.1780976,0.003375068,0.00729927,0,0)
X <- rep(freqs, each=20)
## Fit an LFMM, i.e, compute B, U, V estimates
# ridge vs lasso:
# ridge minimizes sum of squared residuals + lambda * slope squared -> less sensitive to changes in x, lambda is a scaler, the larger lambda the less sensitive y is to x (i.e. flatter the fitted line)
# overall shrinks parameters, making our predictions less sensitive to them
# vs lasso regression: sum of squared residuals + lambda * absolute_value(slope), again making prediction (y) less sensitive to x
# lasso can shrink parameters to 0, ridge can't (when increasing lambda) -> lasso can exclude useless variables from our model
# ridge is more useful when most parameters are useful -> are most of my parameters useful? I think so!
# so I need ridge... let's do both tho and compare results?
# ridge is also the one used in most papers citing the lfmm paper
mod.lfmm <- lfmm_ridge(Y = Y,
X = X,
K = 7) #determined from PCA
## performs association testing using the fitted model:
pv <- lfmm_test(Y = Y,
X = X,
lfmm = mod.lfmm,
calibrate = "gif") #gif is default, and what others use
View(mydata2)
pvalues <- pv$calibrated.pvalue
write.csv(pvalues,"test_pvals")
View(pvalues)
qqplot(rexp(length(pvalues), rate = log(10)),
-log10(pvalues), xlab = "Expected quantile",
pch = 19, cex = .4)
abline(0,1)
## Manhattan plot
plot(-log10(pvalues),
pch = 19,
cex = .9,
xlab = "SNP", ylab = "-Log P",
col = "black")
mydata<-read.matrix("forlapo4", header = FALSE, sep = " ", skip = 0)
#BOD,CAP,FOG,KIB,LOM,SAN,TER
test<-c(2,2,2,0,0,0,0)
test_pos<-rep(test, each=20)
mydata2 <- cbind(mydata, test_pos)
# get genotype data, columns are positions, rows are individuals
#Y <- example.data$genotype
Y <- mydata2
#principal component analysis (PCA) can reveal some ‘structure’ in the genotypic data.
#We perfom PCA by using the prcomp function as follows.
pc <- prcomp(Y)
plot(pc$sdev[1:20]^2, xlab = 'PC', ylab = "Variance explained")
points(6,pc$sdev[6]^2, type = "h", lwd = 3, col = "blue")
View(mydata2)
rep(0.5, each=20)
#order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
BOD <- rep(0.05026657, each=20)
CAP <- rep(0.07188418, each=19)
FOG <- rep(0.1780976, each=18)
rest <- rep(c(0.003375068,0.00729927,0,0), each=20)
BOD + rest
Map(BOD, CAP, FOG)
c(BOD, CAP, FOG)
#order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
BOD <- rep(0.05026657, each=20)
CAP <- rep(0.07188418, each=19)
FOG <- rep(0.1780976, each=18)
rest <- rep(c(0.003375068,0.00729927,0,0), each=20)
X<- c(BOD, CAP, FOG, rest)
X
len(X)
length(X)
C <- as.matrix(read.table("PCangsd_selection.cov"))
ids <- read.table("pca_pops.txt") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
e <- eigen(C)
# base R
plot(e$vectors[,1:2],xlab="PC1",ylab="PC2", bg=ids$V1, pch=21)
#ggplot
library(ggplot2)
library(tidyverse)
install.packages("tidyverse")
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,1], PC2 = e$vectors[,2])
df= rownames_to_column(df)
C <- as.matrix(read.table("PCangsd_selection.cov"))
ids <- read.table("pca_pops.txt") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
e <- eigen(C)
# base R
plot(e$vectors[,1:2],xlab="PC1",ylab="PC2", bg=ids$V1, pch=21)
#ggplot
library(ggplot2)
library(tidyverse)
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,1], PC2 = e$vectors[,2])
C <- as.matrix(read.table("PCangsd_selection.cov"))
ids <- read.table("pca_pops.txt") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
e <- eigen(C)
# base R
plot(e$vectors[,1:2],xlab="PC1",ylab="PC2", bg=ids$V1, pch=21)
#ggplot
library(ggplot2)
library(tidyverse)
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,1], PC2 = e$vectors[,2])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,2], PC2 = e$vectors[,3])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,3], PC2 = e$vectors[,4])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
seq(5)
{
for (val2 in seq(5))
print(val, val2)
}
{
for (val2 in seq(5))
{
print(val, val2)
}
}
{
print(val)
}
seq(5)
seq(5)[1]
for (val in seq(5)){
print(val)
}
for (val in seq(5)){
print(val)
for (val2 in seq(5)) {
print(val ,val2)
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
print(val ,val2)
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
print(val)
print(val2)
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw())
}
}
for (val in seq(2)){
for (val2 in seq(2)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw())
}
}
for (val in seq(2)){
for (val2 in seq(2)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
xlab(val) +
ylab(val2) +
theme_bw())
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
xlab(val) +
ylab(val2) +
theme_bw())
}
}
C <- as.matrix(read.table("PCangsd_selection.cov"))
C <- as.matrix(read.table("PCangsd_selection.cov"))
ids <- read.table("pca_pops2.txt") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
ids <- read.table("pca_pops2") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
e <- eigen(C)
# base R
plot(e$vectors[,1:2],xlab="PC1",ylab="PC2", bg=ids$V1, pch=21)
#ggplot
library(ggplot2)
library(tidyverse)
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,3], PC2 = e$vectors[,4])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
xlab(val) +
ylab(val2) +
theme_bw())
}
}
C <- as.matrix(read.table("PCangsd_selection.cov"))
ids <- read.table("pca_pops3") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
e <- eigen(C)
# base R
plot(e$vectors[,1:2],xlab="PC1",ylab="PC2", bg=ids$V1, pch=21)
#ggplot
library(ggplot2)
library(tidyverse)
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,3], PC2 = e$vectors[,4])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
xlab(val) +
ylab(val2) +
theme_bw())
}
}
install.packages("sdmpredictors")
install.packages("leaflet")
# Load package
library(sdmpredictors)
# Explore datasets in the package
list_datasets()
# Explore layers in a dataset
list_layers()
# Easy download of raster file (Maximum Temperature at the sea bottom)
temp.max.bottom <- load_layers("BO2_tempmax_bdmax")
# Crop raster to fit the North Atlantic
ne.atlantic.ext <- extent(-100, 45, 30.75, 72.5)
library(leaflet)
# List layers avaialble in Bio-ORACLE v2
layers.bio2 <- list_layers( datasets="Bio-ORACLE" )
# Explore datasets in the package
list_datasets()
layers.bio2
View(layers.bio2)
# Download environmental data layers (Max. Temperature, Min. Salinity and Min. Nitrates at the sea bottom)
environment.bottom <- load_layers( layercodes = c("BO2_tempmax_bdmean" , "BO2_salinitymin_bdmean", "BO_ph") , equalarea=FALSE, rasterstack=TRUE)
# Download bathymetry
bathymetry <- load_layers("BO_bathymean")
# Generate a data.frame with the sites of interest
my.sites <- data.frame(Name=c("Faro, Portugal, NE Atlantic" , "Maspalomas, Spain, NE Atlantic" , "Guadeloupe, France, Caribbean Sea" , "Havana, Cuba, Caribbean Sea") , Lon=c(-7.873,-15.539,-61.208,-82.537) , Lat=c(37.047, 27.794,15.957,23.040 ) )
my.sites
# Visualise sites of interest in google maps
m <- leaflet()
m <- addTiles(m)
m <- addMarkers(m, lng=my.sites$Lon, lat=my.sites$Lat, popup=my.sites$Name)
m
m
# Extract environmental values from layers
my.sites.environment <- data.frame(Name=my.sites$Name , depth=extract(bathymetry,my.sites[,2:3]) , extract(environment.bottom,my.sites[,2:3]) )
library(tidyr)
# Extract environmental values from layers
my.sites.environment <- data.frame(Name=my.sites$Name , depth=extract(bathymetry,my.sites[,2:3]) , extract(environment.bottom,my.sites[,2:3]) )
# Download environmental data layers (Max. Temperature, Min. Salinity and Min. Nitrates at the sea bottom)
environment.bottom <- load_layers( layercodes = c("BO2_tempmax_bdmean" , "BO2_salinitymin_bdmean", "BO2_nitratemin_bdmean") , equalarea=FALSE, rasterstack=TRUE)
# Download bathymetry
bathymetry <- load_layers("BO_bathymean")
# Generate a data.frame with the sites of interest
my.sites <- data.frame(Name=c("Faro, Portugal, NE Atlantic" , "Maspalomas, Spain, NE Atlantic" , "Guadeloupe, France, Caribbean Sea" , "Havana, Cuba, Caribbean Sea") , Lon=c(-7.873,-15.539,-61.208,-82.537) , Lat=c(37.047, 27.794,15.957,23.040 ) )
my.sites
# Visualise sites of interest in google maps
m <- leaflet()
m <- addTiles(m)
m <- addMarkers(m, lng=my.sites$Lon, lat=my.sites$Lat, popup=my.sites$Name)
m
# Extract environmental values from layers
my.sites.environment <- data.frame(Name=my.sites$Name , depth=extract(bathymetry,my.sites[,2:3]) , extract(environment.bottom,my.sites[,2:3]) )
library(sdmpredictors)
library(leaflet)
# List layers avaialble in Bio-ORACLE v2
layers.bio2 <- list_layers( datasets="Bio-ORACLE" )
layers.bio2
# Download environmental data layers (Max. Temperature, Min. Salinity and Min. Nitrates at the sea bottom)
environment.bottom <- load_layers( layercodes = c("BO2_tempmax_bdmean" , "BO2_salinitymin_bdmean", "BO2_nitratemin_bdmean") , equalarea=FALSE, rasterstack=TRUE)
# Download bathymetry
bathymetry <- load_layers("BO_bathymean")
# Generate a data.frame with the sites of interest
my.sites <- data.frame(Name=c("Faro, Portugal, NE Atlantic" , "Maspalomas, Spain, NE Atlantic" , "Guadeloupe, France, Caribbean Sea" , "Havana, Cuba, Caribbean Sea") , Lon=c(-7.873,-15.539,-61.208,-82.537) , Lat=c(37.047, 27.794,15.957,23.040 ) )
my.sites
# Visualise sites of interest in google maps
m <- leaflet()
m <- addTiles(m)
m <- addMarkers(m, lng=my.sites$Lon, lat=my.sites$Lat, popup=my.sites$Name)
m
# Extract environmental values from layers
my.sites.environment <- data.frame(Name=my.sites$Name , depth=extract(bathymetry,my.sites[,2:3]) , extract(environment.bottom,my.sites[,2:3]) )
.rs.unloadPackage("tidyr")
# Extract environmental values from layers
my.sites.environment <- data.frame(Name=my.sites$Name , depth=extract(bathymetry,my.sites[,2:3]) , extract(environment.bottom,my.sites[,2:3]) )
install.packages("reshape2")
library(reshape2)
# Extract environmental values from layers
my.sites.environment <- data.frame(Name=my.sites$Name , depth=extract(bathymetry,my.sites[,2:3]) , extract(environment.bottom,my.sites[,2:3]) )
library(raster)
# Extract environmental values from layers
my.sites.environment <- data.frame(Name=my.sites$Name , depth=extract(bathymetry,my.sites[,2:3]) , extract(environment.bottom,my.sites[,2:3]) )
my.sites.environment
View(layers.bio2)
# Download environmental data layers (Max. Temperature, Min. Salinity and Min. Nitrates at the sea bottom)
environment.bottom <- load_layers( layercodes = c("BO2_tempmax_bdmean" , "BO2_salinitymin_bdmean", "BO2_nitratemin_bdmean", "BO_ph") , equalarea=FALSE, rasterstack=TRUE)
# Download bathymetry
bathymetry <- load_layers("BO_bathymean")
# Generate a data.frame with the sites of interest
my.sites <- data.frame(Name=c("Faro, Portugal, NE Atlantic" , "Maspalomas, Spain, NE Atlantic" , "Guadeloupe, France, Caribbean Sea" , "Havana, Cuba, Caribbean Sea") , Lon=c(-7.873,-15.539,-61.208,-82.537) , Lat=c(37.047, 27.794,15.957,23.040 ) )
my.sites
# Visualise sites of interest in google maps
m <- leaflet()
m <- addTiles(m)
m <- addMarkers(m, lng=my.sites$Lon, lat=my.sites$Lat, popup=my.sites$Name)
m
# Extract environmental values from layers
my.sites.environment <- data.frame(Name=my.sites$Name , depth=extract(bathymetry,my.sites[,2:3]) , extract(environment.bottom,my.sites[,2:3]) )
my.sites.environment
View(bathymetry)
my.sites[,2:3]
View(bathymetry)
View(environment.bottom)
# order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
rep(2, each=20)
# order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
BOD <- rep(2, each=20)
CAP <- rep(2, each=19)
FOG <- rep(2, each=18)
rest <- rep(c(0,0,0,0), each=20)
X <- c(BOD, CAP, FOG, rest)
X
# order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
BOD <- rep(1, each=20)
CAP <- rep(1, each=19)
FOG <- rep(2, each=18)
rest <- rep(c(0,0,0,0), each=20)
X <- c(BOD, CAP, FOG, rest)
X
setwd("~/")
df<-read.csv("pcangsd_results.csv")
View(df)
hist(df$V1)
library(topGO)
setwd("~/Desktop/urchin_adaptation/data/Uniprot_GO")
geneID2GO <- readMappings("GO_mapping_topGO") # uniprot to GO mapping
geneNames <- names(geneID2GO)
myInterestingGenes <- read.csv("temp_files_for_GO/uniprotIDs_all_locs.txt", header = FALSE) # list of interesting genes, output of LOC to uniprot mapping
intgenes <- myInterestingGenes[, "V1"]
geneList <- factor(as.integer(geneNames %in% intgenes)) # mask of 0 and 1 if geneName is interesting
names(geneList) <- geneNames # geneList but annotated with the gene names
GOdata <- new("topGOdata",
ontology = "BP", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 10) # top 10 enriched terms
allRes
write.csv(allRes,"all_locs_results_BP_gen_bal2000.csv", row.names = FALSE)
myInterestingGenes <- read.csv("temp_files_for_GO/uniprotIDs_prom_locs.txt", header = FALSE) # list of interesting genes, output of LOC to uniprot mapping
intgenes <- myInterestingGenes[, "V1"]
geneList <- factor(as.integer(geneNames %in% intgenes)) # mask of 0 and 1 if geneName is interesting
names(geneList) <- geneNames # geneList but annotated with the gene names
myInterestingGenes <- read.csv("temp_files_for_GO/uniprotIDs_all_locs.txt", header = FALSE) # list of interesting genes, output of LOC to uniprot mapping
intgenes <- myInterestingGenes[, "V1"]
geneList <- factor(as.integer(geneNames %in% intgenes)) # mask of 0 and 1 if geneName is interesting
names(geneList) <- geneNames # geneList but annotated with the gene names
myInterestingGenes <- read.csv("temp_files_for_GO/uniprotIDs_all_locs.txt", header = FALSE) # list of interesting genes, output of LOC to uniprot mapping
intgenes <- myInterestingGenes[, "V1"]
geneList <- factor(as.integer(geneNames %in% intgenes)) # mask of 0 and 1 if geneName is interesting
names(geneList) <- geneNames # geneList but annotated with the gene names
GOdata <- new("topGOdata",
ontology = "MF", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 18) # top 10 enriched terms
allRes
GOdata <- new("topGOdata",
ontology = "CC", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
GOdata <- new("topGOdata",
ontology = "MF", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 18) # top 10 enriched terms
allRes
write.csv(allRes,"all_locs_results_MF_gen_bal2000.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "CC", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 18) # top 10 enriched terms
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 5) # top 10 enriched terms
allRes
write.csv(allRes,"all_locs_results_CC_gen_bal2000.csv", row.names = FALSE)
myInterestingGenes <- read.csv("temp_files_for_GO/uniprotIDs_prom_locs.txt", header = FALSE) # list of interesting genes, output of LOC to uniprot mapping
intgenes <- myInterestingGenes[, "V1"]
geneList <- factor(as.integer(geneNames %in% intgenes)) # mask of 0 and 1 if geneName is interesting
names(geneList) <- geneNames # geneList but annotated with the gene names
GOdata <- new("topGOdata",
ontology = "BP", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 9) # top 10 enriched terms
allRes
write.csv(allRes,"prom_locs_results_BP_gen_bal2000.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "MF", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 10) # top 10 enriched terms
allRes
write.csv(allRes,"prom_locs_results_MF_gen_bal2000.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "CC", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 1) # top 10 enriched terms
allRes
write.csv(allRes,"prom_locs_results_CC_gen_bal2000.csv", row.names = FALSE)
myInterestingGenes <- read.csv("temp_files_for_GO/uniprotIDs_non_prom_locs.txt", header = FALSE) # list of interesting genes, output of LOC to uniprot mapping
intgenes <- myInterestingGenes[, "V1"]
geneList <- factor(as.integer(geneNames %in% intgenes)) # mask of 0 and 1 if geneName is interesting
names(geneList) <- geneNames # geneList but annotated with the gene names
GOdata <- new("topGOdata",
ontology = "BP", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 9) # top 10 enriched terms
allRes
write.csv(allRes,"non_prom_locs_results_BP_gen_bal2000.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "MF", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 13) # top 10 enriched terms
allRes
write.csv(allRes,"non_prom_locs_results_MF_gen_bal2000.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "CC", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 5) # top 10 enriched terms
allRes
write.csv(allRes,"non_prom_locs_results_CC_gen_bal2000.csv", row.names = FALSE)
