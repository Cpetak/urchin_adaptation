#We perfom PCA by using the prcomp function as follows.
pc <- prcomp(Y)
plot(pc$sdev[1:20]^2, xlab = 'PC', ylab = "Variance explained")
points(6,pc$sdev[6]^2, type = "h", lwd = 3, col = "blue")
#TODO same order as in vcf??
freqs<- c(0,0.00729927,0,0.05026657,0.00337507,0.07188418,0.1780976)
X <- rep(freqs, each=20)
## Fit an LFMM, i.e, compute B, U, V estimates
mod.lfmm <- lfmm_ridge(Y = Y,
X = X,
K = 7) #determined from PCA
## performs association testing using the fitted model:
pv <- lfmm_test(Y = Y,
X = X,
lfmm = mod.lfmm,
calibrate = "gif") #TODO what kind of calibrate to use?
pvalues <- pv$calibrated.pvalue
qqplot(rexp(length(pvalues), rate = log(10)),
-log10(pvalues), xlab = "Expected quantile",
pch = 19, cex = .4)
abline(0,1)
## Manhattan plot
plot(-log10(pvalues),
pch = 19,
cex = .2,
xlab = "SNP", ylab = "-Log P",
col = "grey")
mydata<-read.matrix("forlapo4", header = FALSE, sep = " ", skip = 0)
test<-c(0,0,0,2,0,2,2)
test_pos<-rep(test, each=20)
mydata2 <- cbind(mydata, test_pos)
# get genotype data, columns are positions, rows are individuals
#Y <- example.data$genotype
Y <- mydata2
#principal component analysis (PCA) can reveal some ‘structure’ in the genotypic data.
#We perfom PCA by using the prcomp function as follows.
pc <- prcomp(Y)
plot(pc$sdev[1:20]^2, xlab = 'PC', ylab = "Variance explained")
points(6,pc$sdev[6]^2, type = "h", lwd = 3, col = "blue")
#TODO same order as in vcf??
freqs<- c(0,0.00729927,0,0.05026657,0.00337507,0.07188418,0.1780976)
X <- rep(freqs, each=20)
## Fit an LFMM, i.e, compute B, U, V estimates
mod.lfmm <- lfmm_ridge(Y = Y,
X = X,
K = 7) #determined from PCA
## performs association testing using the fitted model:
pv <- lfmm_test(Y = Y,
X = X,
lfmm = mod.lfmm,
calibrate = "gif") #TODO what kind of calibrate to use?
pvalues <- pv$calibrated.pvalue
qqplot(rexp(length(pvalues), rate = log(10)),
-log10(pvalues), xlab = "Expected quantile",
pch = 19, cex = .4)
abline(0,1)
## Manhattan plot
plot(-log10(pvalues),
pch = 19,
cex = .2,
xlab = "SNP", ylab = "-Log P",
col = "grey")
View(pvalues)
## Manhattan plot
plot(-log10(pvalues),
pch = 19,
cex = .2,
xlab = "SNP", ylab = "-Log P",
col = "black")
## Manhattan plot
plot(-log10(pvalues),
pch = 19,
cex = .9,
xlab = "SNP", ylab = "-Log P",
col = "black")
#devtools::install_github("bcm-uga/lfmm")
library(lfmm)
library(tseries)
setwd("~/")
mydata<-read.matrix("forlapo4", header = FALSE, sep = " ", skip = 0)
test<-c(0,0,0,2,0,2,2)
test_pos<-rep(test, each=20)
mydata2 <- cbind(mydata, test_pos)
# get genotype data, columns are positions, rows are individuals
#Y <- example.data$genotype
Y <- mydata2
#principal component analysis (PCA) can reveal some ‘structure’ in the genotypic data.
#We perfom PCA by using the prcomp function as follows.
pc <- prcomp(Y)
plot(pc$sdev[1:20]^2, xlab = 'PC', ylab = "Variance explained")
points(6,pc$sdev[6]^2, type = "h", lwd = 3, col = "blue")
#order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
freqs<- c(0.05026657,0.07188418,0.1780976,0.003375068,0.00729927,0,0)
X <- rep(freqs, each=20)
mydata<-read.matrix("forlapo4", header = FALSE, sep = " ", skip = 0)
#BOD,CAP,FOG,KIB,LOM,SAN,TER
test<-c(2,2,2,0,0,0,0)
test_pos<-rep(test, each=20)
mydata2 <- cbind(mydata, test_pos)
# get genotype data, columns are positions, rows are individuals
#Y <- example.data$genotype
Y <- mydata2
#principal component analysis (PCA) can reveal some ‘structure’ in the genotypic data.
#We perfom PCA by using the prcomp function as follows.
pc <- prcomp(Y)
plot(pc$sdev[1:20]^2, xlab = 'PC', ylab = "Variance explained")
points(6,pc$sdev[6]^2, type = "h", lwd = 3, col = "blue")
#order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
freqs<- c(0.05026657,0.07188418,0.1780976,0.003375068,0.00729927,0,0)
X <- rep(freqs, each=20)
## Fit an LFMM, i.e, compute B, U, V estimates
# ridge vs lasso:
# ridge minimizes sum of squared residuals + lambda * slope squared -> less sensitive to changes in x, lambda is a scaler, the larger lambda the less sensitive y is to x (i.e. flatter the fitted line)
# overall shrinks parameters, making our predictions less sensitive to them
# vs lasso regression: sum of squared residuals + lambda * absolute_value(slope), again making prediction (y) less sensitive to x
# lasso can shrink parameters to 0, ridge can't (when increasing lambda) -> lasso can exclude useless variables from our model
# ridge is more useful when most parameters are useful -> are most of my parameters useful? I think so!
# so I need ridge... let's do both tho and compare results?
# ridge is also the one used in most papers citing the lfmm paper
mod.lfmm <- lfmm_ridge(Y = Y,
X = X,
K = 7) #determined from PCA
## performs association testing using the fitted model:
pv <- lfmm_test(Y = Y,
X = X,
lfmm = mod.lfmm,
calibrate = "gif") #gif is default, and what others use
pvalues <- pv$calibrated.pvalue
qqplot(rexp(length(pvalues), rate = log(10)),
-log10(pvalues), xlab = "Expected quantile",
pch = 19, cex = .4)
abline(0,1)
## Manhattan plot
plot(-log10(pvalues),
pch = 19,
cex = .9,
xlab = "SNP", ylab = "-Log P",
col = "black")
View(mydata2)
View(pvalues)
mydata<-read.matrix("forlapo4", header = FALSE, sep = " ", skip = 0)
#BOD,CAP,FOG,KIB,LOM,SAN,TER
test<-c(2,2,2,0,0,0,0)
test_pos<-rep(test, each=20)
mydata2 <- cbind(mydata, test_pos)
# get genotype data, columns are positions, rows are individuals
#Y <- example.data$genotype
Y <- mydata2
#principal component analysis (PCA) can reveal some ‘structure’ in the genotypic data.
#We perfom PCA by using the prcomp function as follows.
pc <- prcomp(Y)
plot(pc$sdev[1:20]^2, xlab = 'PC', ylab = "Variance explained")
points(6,pc$sdev[6]^2, type = "h", lwd = 3, col = "blue")
#order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
freqs<- c(0.05026657,0.07188418,0.1780976,0.003375068,0.00729927,0,0)
X <- rep(freqs, each=20)
## Fit an LFMM, i.e, compute B, U, V estimates
# ridge vs lasso:
# ridge minimizes sum of squared residuals + lambda * slope squared -> less sensitive to changes in x, lambda is a scaler, the larger lambda the less sensitive y is to x (i.e. flatter the fitted line)
# overall shrinks parameters, making our predictions less sensitive to them
# vs lasso regression: sum of squared residuals + lambda * absolute_value(slope), again making prediction (y) less sensitive to x
# lasso can shrink parameters to 0, ridge can't (when increasing lambda) -> lasso can exclude useless variables from our model
# ridge is more useful when most parameters are useful -> are most of my parameters useful? I think so!
# so I need ridge... let's do both tho and compare results?
# ridge is also the one used in most papers citing the lfmm paper
mod.lfmm <- lfmm_ridge(Y = Y,
X = X,
K = 7) #determined from PCA
## performs association testing using the fitted model:
pv <- lfmm_test(Y = Y,
X = X,
lfmm = mod.lfmm,
calibrate = "gif") #gif is default, and what others use
View(mydata2)
pvalues <- pv$calibrated.pvalue
write.csv(pvalues,"test_pvals")
View(pvalues)
qqplot(rexp(length(pvalues), rate = log(10)),
-log10(pvalues), xlab = "Expected quantile",
pch = 19, cex = .4)
abline(0,1)
## Manhattan plot
plot(-log10(pvalues),
pch = 19,
cex = .9,
xlab = "SNP", ylab = "-Log P",
col = "black")
mydata<-read.matrix("forlapo4", header = FALSE, sep = " ", skip = 0)
#BOD,CAP,FOG,KIB,LOM,SAN,TER
test<-c(2,2,2,0,0,0,0)
test_pos<-rep(test, each=20)
mydata2 <- cbind(mydata, test_pos)
# get genotype data, columns are positions, rows are individuals
#Y <- example.data$genotype
Y <- mydata2
#principal component analysis (PCA) can reveal some ‘structure’ in the genotypic data.
#We perfom PCA by using the prcomp function as follows.
pc <- prcomp(Y)
plot(pc$sdev[1:20]^2, xlab = 'PC', ylab = "Variance explained")
points(6,pc$sdev[6]^2, type = "h", lwd = 3, col = "blue")
View(mydata2)
rep(0.5, each=20)
#order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
BOD <- rep(0.05026657, each=20)
CAP <- rep(0.07188418, each=19)
FOG <- rep(0.1780976, each=18)
rest <- rep(c(0.003375068,0.00729927,0,0), each=20)
BOD + rest
Map(BOD, CAP, FOG)
c(BOD, CAP, FOG)
#order of vcf: BOD,CAP,FOG,KIB,LOM,SAN,TER
BOD <- rep(0.05026657, each=20)
CAP <- rep(0.07188418, each=19)
FOG <- rep(0.1780976, each=18)
rest <- rep(c(0.003375068,0.00729927,0,0), each=20)
X<- c(BOD, CAP, FOG, rest)
X
len(X)
length(X)
C <- as.matrix(read.table("PCangsd_selection.cov"))
ids <- read.table("pca_pops.txt") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
e <- eigen(C)
# base R
plot(e$vectors[,1:2],xlab="PC1",ylab="PC2", bg=ids$V1, pch=21)
#ggplot
library(ggplot2)
library(tidyverse)
install.packages("tidyverse")
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,1], PC2 = e$vectors[,2])
df= rownames_to_column(df)
C <- as.matrix(read.table("PCangsd_selection.cov"))
ids <- read.table("pca_pops.txt") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
e <- eigen(C)
# base R
plot(e$vectors[,1:2],xlab="PC1",ylab="PC2", bg=ids$V1, pch=21)
#ggplot
library(ggplot2)
library(tidyverse)
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,1], PC2 = e$vectors[,2])
C <- as.matrix(read.table("PCangsd_selection.cov"))
ids <- read.table("pca_pops.txt") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
e <- eigen(C)
# base R
plot(e$vectors[,1:2],xlab="PC1",ylab="PC2", bg=ids$V1, pch=21)
#ggplot
library(ggplot2)
library(tidyverse)
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,1], PC2 = e$vectors[,2])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,2], PC2 = e$vectors[,3])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,3], PC2 = e$vectors[,4])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
seq(5)
{
for (val2 in seq(5))
print(val, val2)
}
{
for (val2 in seq(5))
{
print(val, val2)
}
}
{
print(val)
}
seq(5)
seq(5)[1]
for (val in seq(5)){
print(val)
}
for (val in seq(5)){
print(val)
for (val2 in seq(5)) {
print(val ,val2)
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
print(val ,val2)
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
print(val)
print(val2)
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw())
}
}
for (val in seq(2)){
for (val2 in seq(2)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw())
}
}
for (val in seq(2)){
for (val2 in seq(2)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
xlab(val) +
ylab(val2) +
theme_bw())
}
}
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
xlab(val) +
ylab(val2) +
theme_bw())
}
}
C <- as.matrix(read.table("PCangsd_selection.cov"))
C <- as.matrix(read.table("PCangsd_selection.cov"))
ids <- read.table("pca_pops2.txt") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
ids <- read.table("pca_pops2") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
e <- eigen(C)
# base R
plot(e$vectors[,1:2],xlab="PC1",ylab="PC2", bg=ids$V1, pch=21)
#ggplot
library(ggplot2)
library(tidyverse)
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,3], PC2 = e$vectors[,4])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
xlab(val) +
ylab(val2) +
theme_bw())
}
}
C <- as.matrix(read.table("PCangsd_selection.cov"))
ids <- read.table("pca_pops3") #text file with 20 lines of the single word BOD, then 20 lines of CAP etc in the order they appeared in all_rmdups_jo.txt
e <- eigen(C)
# base R
plot(e$vectors[,1:2],xlab="PC1",ylab="PC2", bg=ids$V1, pch=21)
#ggplot
library(ggplot2)
library(tidyverse)
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,3], PC2 = e$vectors[,4])
df= rownames_to_column(df)
ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
theme_bw()
for (val in seq(5)){
for (val2 in seq(5)) {
df <- data.frame(pop = ids$V1, PC1 = e$vectors[,val], PC2 = e$vectors[,val2])
df= rownames_to_column(df)
print(ggplot(df, aes(x=PC1, y=PC2, fill=pop)) +
geom_point(size=3, shape=21) +
xlab(val) +
ylab(val2) +
theme_bw())
}
}
library(topGO)
setwd("~/Desktop/urchin_adaptation/data/Uniprot_GO")
geneID2GO <- readMappings("GO_mapping_topGO") # uniprot to GO mapping
geneNames <- names(geneID2GO)
myInterestingGenes <- read.csv("temp_files_for_GO/uniprotIDs_all_locs.txt", header = FALSE) # list of interesting genes, output of LOC to uniprot mapping
intgenes <- myInterestingGenes[, "V1"]
geneList <- factor(as.integer(geneNames %in% intgenes)) # mask of 0 and 1 if geneName is interesting
names(geneList) <- geneNames # geneList but annotated with the gene names
GOdata <- new("topGOdata",
ontology = "BP", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 63) # top 10 enriched terms
allRes
write.csv(allRes,"all_locs_results_BP.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "MF", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 58) # top 10 enriched terms
allRes
write.csv(allRes,"all_locs_results_MF.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "CC", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 11) # top 10 enriched terms
allRes
write.csv(allRes,"all_locs_results_CC.csv", row.names = FALSE)
myInterestingGenes <- read.csv("temp_files_for_GO/uniprotIDs_non_prom_locs.txt", header = FALSE) # list of interesting genes, output of LOC to uniprot mapping
intgenes <- myInterestingGenes[, "V1"]
geneList <- factor(as.integer(geneNames %in% intgenes)) # mask of 0 and 1 if geneName is interesting
names(geneList) <- geneNames # geneList but annotated with the gene names
GOdata <- new("topGOdata",
ontology = "BP", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 68) # top 10 enriched terms
allRes
write.csv(allRes,"non_prom_locs_results_BP.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "MF", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 64) # top 10 enriched terms
allRes
write.csv(allRes,"non_prom_locs_results_MF.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "CC", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 11) # top 10 enriched terms
allRes
write.csv(allRes,"non_prom_locs_results_CC.csv", row.names = FALSE)
myInterestingGenes <- read.csv("temp_files_for_GO/uniprotIDs_prom_locs.txt", header = FALSE) # list of interesting genes, output of LOC to uniprot mapping
intgenes <- myInterestingGenes[, "V1"]
geneList <- factor(as.integer(geneNames %in% intgenes)) # mask of 0 and 1 if geneName is interesting
names(geneList) <- geneNames # geneList but annotated with the gene names
GOdata <- new("topGOdata",
ontology = "BP", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 14) # top 10 enriched terms
allRes
write.csv(allRes,"prom_locs_results_BP.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "MF", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 8) # top 10 enriched terms
allRes
write.csv(allRes,"prom_locs_results_MF.csv", row.names = FALSE)
GOdata <- new("topGOdata",
ontology = "CC", # ontology of interest (BP, MF or CC)
allGenes = geneList,
annot = annFUN.gene2GO,
gene2GO = geneID2GO)
resultFisher <- runTest(GOdata, algorithm = "classic", statistic = "fisher") # these are the options I'll be using! checked!
resultFisher
allRes <- GenTable(GOdata, classicFisher = resultFisher, topNodes = 3) # top 10 enriched terms
allRes
write.csv(allRes,"prom_locs_results_CC.csv", row.names = FALSE)
